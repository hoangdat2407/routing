####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq


class LSrouter(Router):
    """Link state routing protocol implementation.

    This version only **adds** code; original comments and structure are retained.
    Implements a basic OSPF‑like link‑state algorithm with flooding and Dijkstra.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # --- ADDED FIELDS ---------------------------------------------------
        self.seq_num = 0                  # our own sequence number
        self.neighbors = {}              # port -> (nbr_addr, cost)
        self.ports = {}                  # nbr_addr -> port (reverse map)
        self.lsdb = {}                   # addr -> (seq, links_dict)
        self.forwarding_table = {}       # dst_addr -> port
        # --------------------------------------------------------------------
        self._update_own_lsdb()

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO (logic added below)
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            out_port = self.forwarding_table.get(packet.dst_addr)
            if out_port is not None:
                self.send(out_port, packet)
            # If unknown destination, silently drop.
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            try:
                lsp = json.loads(packet.content)
                src = lsp["src"]
                seq = lsp["seq"]
                links = lsp["links"]
            except Exception:
                return  # malformed routing packet

            old_seq, old_links = self.lsdb.get(src, (-1, None))
            if seq <= old_seq:
                return  # stale LSP

            # Update LSDB and forwarding
            self.lsdb[src] = (seq, links)
            if links != old_links:
                self._recompute_forwarding()

            # Flood further (except incoming port)
            self._flood(packet, except_port=port)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO: update local data structures and forwarding table
        #       broadcast the new link state of this router to all neighbors
        self.neighbors[port] = (endpoint, cost)
        self.ports[endpoint] = port
        self.seq_num += 1
        self._update_own_lsdb()
        self._recompute_forwarding()
        self._flood(self._make_lsp())

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO: update local data structures and forwarding table
        #       broadcast the new link state of this router to all neighbors
        if port not in self.neighbors:
            return
        endpoint, _ = self.neighbors.pop(port)
        self.ports.pop(endpoint, None)
        self.seq_num += 1
        self._update_own_lsdb()
        self._recompute_forwarding()
        self._flood(self._make_lsp())

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO: broadcast the link state of this router to all neighbors
            self._flood(self._make_lsp())

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        tbl = ", ".join(f"{d}->{p}" for d, p in self.forwarding_table.items())
        return f"LSrouter(addr={self.addr}, fwd={{ {tbl} }})"

    # ----------------------------------------------------------------------
    #                               HELPERS
    # ----------------------------------------------------------------------
    def _make_lsp(self):
        """Create an LSP packet containing this router's current links."""
        body = {
            "src": self.addr,
            "seq": self.seq_num,
            "links": {nbr: cost for nbr, cost in (c for c in [self.neighbors[p] for p in self.neighbors])},
        }
        return Packet(Packet.ROUTING, self.addr, "*", json.dumps(body))

    def _flood(self, packet, except_port=None):
        """Send *packet* out every port except except_port."""
        for p in self.links:
            if p != except_port:
                self.send(p, packet)

    def _update_own_lsdb(self):
        """Store or refresh our own LSP in LSDB."""
        self.lsdb[self.addr] = (
            self.seq_num,
            {nbr: cost for nbr, cost in (c for c in [self.neighbors[p] for p in self.neighbors])},
        )

    def _recompute_forwarding(self):
        """Run Dijkstra to rebuild forwarding table."""
        # Build adjacency map
        graph = {}
        for node, (_, links) in self.lsdb.items():
            graph.setdefault(node, {})
            for nbr, cost in links.items():
                graph[node][nbr] = cost
        # Ensure our node exists even if temporarily isolated
        graph.setdefault(self.addr, {})

        # Dijkstra
        dist = {self.addr: 0}
        first_hop = {}
        pq = [(0, self.addr, None)]
        while pq:
            d, u, via = heapq.heappop(pq)
            if d != dist.get(u):
                continue
            for v, w in graph.get(u, {}).items():
                nd = d + w
                if nd < dist.get(v, float("inf")):
                    dist[v] = nd
                    first_hop[v] = via if via else v
                    heapq.heappush(pq, (nd, v, first_hop[v]))

        # Fill forwarding table
        self.forwarding_table.clear()
        for dst, hop in first_hop.items():
            if dst == self.addr:
                continue
            out_port = self.ports.get(hop)
            if out_port is not None:
                self.forwarding_table[dst] = out_port
